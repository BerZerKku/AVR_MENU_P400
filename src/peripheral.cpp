//Начальные установки ATmega162
#include <ioavr.h>
#include <ina90.h>
#include "peripheral.h"
#include "board.h"

/// Включение прерываний.
void PERIF_intrEnable(void) {
    __enable_interrupt();
}

/// Настройка периферии.
void PERIF_setup(void) {
    //Настройка портов
    //все порты настроены на вход и находятся в Z-состоянии
    
    // Шина данных D для управления ЖКИ
    DDRA  = 0xFF;   
    PORTA = 0x00;   
    
    DDRB  = (1 << PIN_RS) | (1 << PIN_ESTR);    
    PORTB = (1 << PIN_RS);   
    
    // Порт для работы с клавиатурой 
    DDRC  = 0x00;
    PORTC = 0x00;  
    
    DDRD  = (1 << PIN_SWMUX);
    PORTD = (0 << PIN_SWMUX);
    
    // Таймер 0
    // режим по совпадению
    TCCR0 = (1 << WGM01) | (0 << WGM00);
    // делитель N = 64 -> тик = 1 / (16e6 / 256) = 4 мкс
    // TCCR0 |= (0 << CS02) | (1 << CS01) | (1 << CS00);
    // время срабатывания = тик * (1 + OCR)
    // счет до 250, т.е. время срабатывания = 4 мкс * 250 = 1 мс 
    OCR0 = 250 - 1;
    TIMSK |= (1 << OCIE0);    
    
    // Таймер 1
	// режим сброс по совпадению A
    TCCR1A = (0 << WGM11) | (0 << WGM10);
    TCCR1B = (0 << WGM13) | (1 << WGM12);
    // тик = 1 / (F_CPU / N)
    // делитель N = 256 -> тик = 1 / (16e6 / 256) = 16 мкс
    // TCCR1B |= (1 << CS12) | (0 << CS11) | (0 << CS10); 
    TCCR1C  = 0;
    TCNT1 = 0;
    // время срабатывания = тик * (1 + OCR)
    // счет до 6250, т.е. время срабатывания = 16 мкс * 6250 = 100 мс
    OCR1A = 6250 - 1;    
    TIMSK |= (1 << OCIE1A);
    
    // Таймер 2
    // режим по совпадению
    TCCR2 = (1 << WGM21) | (0 << WGM20);
    // делитель N = 64 -> тик = 1 / (16e6 / 256) = 4 мкс
    // TCNT2 |= (0 << CS22) | (1 << CS21) | (1 << CS20);
    // время срабатывания = тик * (1 + OCR)
    // счет до 250, т.е. время срабатывания = 4 мкс * 250 = 1 мс
    OCR2 = 250 - 1;
    TIMSK |= (1 << OCIE2);
}

/// Запуск Таймера0
void PERIF_timer0Start(void) {
    TCCR0 |= (0 << CS02) | (1 << CS01) | (1 << CS00); 
}

/// Запуск Таймера1
void PERIF_timer1Start(void) {
    TCCR1B |= (1 << CS12) | (0 << CS11) | (0 << CS10); 
}

/// Запуск Таймера2
void PERIF_timer2Start(void) {
    TCCR2 |= (0 << CS12) | (1 << CS11) | (1 << CS10); 
}

/** Сброс сторожевого таймера.
 *
 *  Необходимо вызывать до того как сработает WD.
 */
void PERIF_wdReset(void) {
    __watchdog_reset();
}

/** Запуск сторожевого таймера.
 *
 *  Время срабатывания таймера примерно 0.24 секунды.
 */
void PERIF_wdStart(void) {
    __watchdog_reset();
    
    WDTCR  = (1 << WDE) | (1 << WDCE);    
    WDTCR |= (1 << WDP2) | (0 << WDP1) | (0 << WDP0); // Time-out ~ 0.24s
}




